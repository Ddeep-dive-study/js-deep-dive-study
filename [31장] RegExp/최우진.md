## 31.1 정규 표현식이란?

---

- 정규 표현식(regular expression)
    - 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어(formal language)다.
    - 문자열을 대상으로 패턴 매칭 기능을 제공한다.
        - 패턴 매칭 기능이란??
        특정 패턴과 일치하는 문 자열을 검색하거나 추출 또는 치환할 수 있는 기능

## 31.2 정규 표현식의 생성

---

- 정규 표현식 객체(RegExp 객체) 생성 방법
    1. 정규 표현식 리터럴 사용 → 일반적으로 이게 좋음👍
        
        ![스크린샷 2024-09-05 오후 5.16.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/97f6111f-bac5-40a8-9888-f7bf5d03ec9b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.16.23.png)
        
        ⇒ 정규 표현식 리터럴은 패턴과 플래그로 구성된다.
        
        ```jsx
        const target = 'Is this all there is?';
        
        // 패턴: is
        // 플래그: i => 대소문자를 구별하지 않고 검색한다. 
        const regexp = /is/i;
        
        // test 메서드는 target 문자열에 대해 정규 표현식 regexp의 패턴을 검색하여 매칭 결과를 
        // 불리언 값으로 반환한다.
        regexp.test(target); // -> true
        ```
        
    2. RegExp 생성자 함수 사용
        
        ```jsx
        /**
        * pattern: 정규 표현식의 패턴
        * flags: 정규 표현식의 플래그(g, i, m, u, y) 
        */
        
        new RegExp(pattern[, flags])
        const target = 'Is this all there is?';
        
        const regexp = new RegExp(/is/i); // ES6 
        // const regexp = ne􏰀 RegExp(/is/, 'i'); 
        // const regexp = ne􏰀 RegExp('is', 'i');
        
        regexp.test(target); // 􏰂 true
        ```
        

## 31.3. RegExp 메서드

---

### **31.3.1 RegExp**.**prototype**.**exec**

- exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다.
- 매칭 결과가 없는 경우 null을 반환한다.

### **31.3.2 RegExp**.**prototype**.**test**

- test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환한다.

### **31.3.3 String**.**prototype**.**match**

- String 표준 빌트인 객체가 제공하는 match 메서드는 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.

## 31.4 플래그

---

![스크린샷 2024-09-05 오후 5.22.29.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/0c8d1cda-191a-46f7-8cb1-9a49074700a3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.22.29.png)

## 31.5 패턴

---

- 정규 표현식은 패턴과 플래그로 구성된다.
    - 패턴 → 문자열의 일정한 규칙을 표현하기 위해 사용.
            → /로 열고 닫음. 문자열의 따옴표는 생략.
    - 플래그 → 정규 표현식의 검색 방식을 설정하기 위해 사용.

### 31.5.1 문자열 검색

- 정규 표현식의 패턴에 문자 또는 문자열을 지정하면 검색 대상 문자열에서 패턴으로 지정한 문자 또는 문자열을 검색한다.
- 물론 정규 표현식을 생성하는 것만으로 검색이 수행 되지는 않는다.
- 앞서 살펴본 RegExp 메서드를 사용하여 검색 대상 문자열과 정규 표현식의 매칭 결과를 구하면 검색이 수행된다.

1. 대소문자를 구별하지 않고 검색하려면 플래그 i를 사용한다.
2. 검색 대상 문자열 내에서 패턴과 매치하는 모든 문자열을 전역 검색하려면 플래그 g를 사용한다.

### **31.5.2** 임의의 문자열 검색

- .은 임의의 문자 한 개를 의미한다.
- 문자의 내용은 무엇이든 상관없다.

### **31.5.3** 반복 검색

- {m,n}은 최소 m번, 최대 n번 반복되는 문자열을 의미한다.
- 콤마 뒤에 공백이 있으면 정상 동작하지 않는다.

1. {n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다. 즉, {n}은 {n, n}과 같다.
2. {n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.
3. +는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. 즉,+는{1,}과 같다.
4. ?는 앞선 패턴이 최대 한 번(0번 포함) 이상 반복되는 문자열을 의미한다. 즉, ?는 {0,1}과 같다.

### **31.5.4** OR 검색

- |은 or의 의미를 갖는다.
- 분해되지 않은 단어 레벨로 검색하기 위해서는 +를 함께 사용한다.
- \d는 숫자를 의미한다.
- \w는 알파벳, 숫자, 언더스코어를 의미한다. → \W와 반대로 동작
- \W는 알파벳, 숫자, 언더스코어가 아닌 문자를 의미한다.

### **31.5.5** NOT 검색

- [...] 내의 ^은 not의 의미를 갖는다.

### **31.5.6** 시작 위치로 검색

- [...] 밖의 ^은 문자열의 시작을 의미한다.
- 단, [...] 내의 ^은 not의 의미를 가진다.

### **31.5.7** 마지막 위치로 검색

- $는 문자열의 마지막을 의미한다.

## 31.6 자주 사용하는 정규표현식

---

### **31.6.1** 특정 단어로 시작하는지 검사

- [...] 바깥의 ^은 문자열의 시작을 의미하고, ?은 앞선 패턴이 최대 한 번(0번 포함)이상 반복되는지를 의미한다.

### **31.6.2** 특정 단어로 끝나는지 검사

- `$`는 문자열의 마지막을 의미한다.

### **31.6.3** 숫자로만 이루어진 문자열인지 검사

- [...] 바깥의 ^은 문자열의 시작을, $는 문자열의 마지막을 의미한다.
- \d는 숫자를 의미하고 +는 최소 한 번 이상 반복되는 문자열을 의미한다.

### **31.6.4** 하나 이상의 공백으로 시작하는지 검사

- \s는 여러 가지 공백 문자(스페이스, 탭 등)를 의미한다.

### **31.6.5** 아이디로 사용 가능한지 검사

- {4,10}은 알파벳 대소문자 또는 숫자가 최소 4번, 최대 10번 반복되는 문자열을 의미한다.

### **31.6.6** 메일 주소 형식에 맞는지 검사

```jsx
const email = 'ungmo2@gmail.com';
/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/. 
test(email); // -> true

(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\ 
x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0- 
9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4] 
[0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a- 
z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e- 
\x7f])+)\])
```

### **31.6.7** 핸드폰 번호 형식에 맞는지 검사

```jsx
const cellphone = '010-1234-5678'; 
/^\d{3}-\d{3,4}-\d{4}$/.test(cellphone); // 􏰂 true
```

### **31.6.8** 특수 문자 포함 여부 검사

```jsx
const target = 'abc#123'; 
(/[^A-Za-z0-9]/gi).test(target); // -> true

(/[\{\}\[\]\/?.,;:|\)*~`!^\-_+<>@\#$%&\\\=\(\'\"]/gi).test(target); // -> true
```

```jsx
// 특수 문자를 제거할 때는 String.prototype.replace 메서드를 사용한다.

// 특수 문자를 제거한다. 
target.replace(/[^A-Za-z0-9]/gi, ''); // 􏰂 abc123
```
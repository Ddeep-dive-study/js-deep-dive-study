# 💡 12장 함수

## 12.1 함수란?

---

- **함수 : 자바스크립트에서 가장 중요한 핵심 개념**
    - 수학에서의 함수 : **입력(input)**을 받아 **출력(output)**을 내보내는 일련의 과정
    - 프로그래밍 언어의 함수 = 수학의 함수 ⇒ 둘이 같은 개념
- **스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 → 모두 함수와 깊은 연관**

- **프로그래밍 언어의 함수**
    - 일련의 과정을 **Statement(문)**으로 구현 → 코드 블록으로 감싸서 하나의 실행 단위로 정의
    - 함수 내부로 입력을 전달 받는 변수 → **parameter(매개변수), argument(인수), return value(반환값)**
    - 함수 = 값
    - 특정함수를 구별하기 위해 식별자인 함수 이름 사용
        
        ![스크린샷 2024-07-23 오전 12.45.44.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/ea6c56e7-2826-492f-9936-badb548681d6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.45.44.png)
        
    - 함수의 정의만으로 함수 실행❌
    - 입력, 즉 **argument(인수)**를 매개변수를 통해 함수에 전달 → 함수의 실행 명시적으로 지시
    ⇒ 이를 **function call/invoke(함수 호출)** → 코드 블록에 담긴 statement 실행 → 실행 결과(반환값) 반환

## 12.2 함수를 사용하는 이유

---

- **코드의 재사용**
    - 함수는 필요할 때 여러 번 호출⭕
    - 동일한 작업 수행할 때→ 같은 코드 중복해서 여러번 작성❌
                                         ⇒ 이미 정의된 함수 재사용 → 효율성⬆
    - 코드의 중복 억제 & 재사용성⬆ ⇒ 유지보수의 편의성⬆, 실수⬇, 코드의 신뢰성⬆
    - 함수 = 객체 타입의 값
    - 함수의 이름 = 식별자 → 코드의 가독성⬆

## 12.3 함수 리터럴

---

- 자바스크립트의 함수 = 객체 타입의 값
- Literal(리터럴) = 데이터(값) 그 자체
    - 숫자 값 → 숫자 리터럴 생성, 객체 값 → 객체 리터럴 생성, 함수 값 → 함수 생성
    - 함수 리터럴 → function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성
        - ex) function add(x, y)
            
            ![스크린샷 2024-07-23 오전 12.46.56.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/3aa2d9db-c98a-4119-b11e-0bbd64c05742/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.46.56.png)
            
    - 함수 → 값 생성 → 이 값은 객체 → **함수는 객체다‼**
        - 함수=객체!! → 하지만, 일반 객체와는 다름!
            - 일반 객체 → 호출❌
            - 함수 → 호출⭕
        - 함수 객체 만의 고유한 프로퍼피 가짐.
        - **⭐⭐⭐
        함수 = 객체 ⇒ 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징‼**

## 12.4 함수 정의

---

![스크린샷 2024-07-23 오전 12.49.09.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/5b5aa06d-4a78-4224-a79a-086bb8c292de/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.49.09.png)

- 변수 → 선언(declaration).          함수 → 정의(definition)

### 12.4.1 함수 선언문

- 함수 선언문의 형태 = 함수 리터럴의 형태
    - 함수 선언문 → 함수 이름 생략❌
    - 함수 리터럴 → 함수 이름 생략⭕️
- 함수 선언문 → 표현식❌      문(statement)⭕️
- 문 → 변수 할당❌
- **{ } ⇒ 블록문? VS 객체 리터럴?**
    - **{ } 단독 존재 → 블록문 → 함수 선언문**
        
        ![스크린샷 2024-07-23 오전 1.11.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/d41ae98f-6a2f-4271-97f8-f85515e417a0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.11.57.png)
        
    - **{ } 피연산자로 사용(값으로 평가되어야 할 문맥) → 객체 리터럴 → 함수 리터럴**
        
        ![스크린샷 2024-07-23 오전 1.18.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/45b30f15-f991-4fb4-a9c2-1b14ffb9358e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.18.11.png)
        
    - 함수 리터럴 → 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자
    ⇒ 함수 몸체 외부에서는 함수 이름으로 함수 참조❌ → 함수 호출❌ → 함수를 가리키는 식별자❌
- 자바스크립트 엔진은 **함수 이름과 동일한 이름의 식별자를 암묵적으로 생성 & 함수 객체 할당**
    - why?? ⇒ 생성된 함수를 호출하기 위해
    
    ![스크린샷 2024-07-23 오전 1.26.08.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/dbce2437-f3d6-4cfe-99ea-59469178ac62/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.26.08.png)
    
- 함수 이름으로 호출❌ → 함수 객체를 가리키는 식별자로 호출⭕️
    
    ![스크린샷 2024-07-23 오전 1.26.31.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/6f1e33bf-9a20-458f-8a64-20cd0d073c25/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.26.31.png)
    
- 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체 생성‼️

### **12.4.2 함수 표현식**

- 자바스크립트의 함수 = 일급 객체
    - 함수를 값처럼 자유롭게 사용⭕️
    - 함수 리터럴로 생성한 함수 객체를 변수에 할당⭕️ → 함수 표현식(function expression)
    - 함수 리터럴의 함수 이름 생략⭕️ → 익명 함수
    - 함수 표현식의 함수 리터럴 → 함수 이름 생략⭕️

![스크린샷 2024-07-23 오전 1.34.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/565d5850-f81a-4a80-82c6-4f1310499cc1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.34.20.png)

- 함수 호출 시)
    - 함수 이름❌ → 함수 객체를 가리키는 식별자 사용‼️
    - 함수 이름은 함수 몸체 내부에서만 유효한 식별자 → 함수 이름으로 함수 호출❌
- 자바스크립트 엔진 → 함수 선언문의 함수 이름으로 식별자 암묵적 생성 & 생성된 함수 객체 할당
    - 함수 표현식과 유사하게 동작하는 것처럼 보임.
    - 하지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않음.
- **함수 선언문 = “표현식이 아닌 문”**
- **함수 표현식 = “표현식인 문”**

### 12.4.3 함수 생성 시점과 함수 호이스팅

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름.
    - 함수 선언문으로 정의한 함수 → 함수 선언문 이전에 호출⭕️
    - 함수 표현식으로 정의한 함수 → 함수 표현식 이전엔 호출❌
- 함수 선언문으로 정의한 함수
    - 함수 선언문 이전 → 함수 참조⭕️ 호출⭕️ ⇒ **함수 호이스팅**
    - 런타임 이전에 함수 객체 먼저 생성
    - 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자 암묵적으로 생성 & 생성된 함수 객체 할당.
    - 런타임에는 이미 함수 객체 생성 & 함수 이름과 동일한 식별자에 할당까지 완료된 상태
- 함수 표현식으로 정의한 함수
    - 함수 표현식 이전에 호출 ❌
    - 변수에 할당되는 값이 함수 리터럴인 문
    - 변수 선언문과 변수 할당문을 한번 기술한 축약 표현과 동일하게 동작
    - 함수 표현식으로 함수 정의 → 함수 호이스팅 발생❌   변수 호이스팅 발생⭕️
- **함수 호이스팅**
    - **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징**
    - 선언 자체는 맨 위로,,

![스크린샷 2024-07-23 오전 1.49.13.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/518b7426-6366-47d5-bdb5-6968024d3aed/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-23_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.49.13.png)

- ⇒ 함수 선언문 대신 함수 표현식 사용 권장‼️

### 12.4.4 Function 생성자 함수

- Function 생성자 함수
    - 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출 → 함수 객체를 생성해서 반환.
    - new 연산자❌ 호출 → 결과 동일
    - 함수를 생성하는 방식은 일반적❌ 바람직❌
    - 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작
- 지금은 함수 선언문이나 함수 표현식으로 생성한 함수와 Function 생성자 함수로 생성한 함수가 동일하게 동작하지 않는다는 데 주목‼️

### **12.4.5 화살표 함수**

- function 키워드 대신 화살표(fat arrow) => 사용 → 간략한 방법으로 함수 선언⭕️
    - 항상 익명 함수로 정의
        - **익명함수란??**
        → 연결된 이름이 없는 함수
        → function 키워드 뒤에 함수 이름❌ → function 키워드만 사용‼️
    - 기존의 함수보다 간략 + 내부 동작 간략화

## 12.5 함수 호출

---

- 함수 → 식별자(=함수) & 호출 연산자(=( )) ⇒ 함수 호출‼️

### 12.5.1 매개변수와 인수

- 함수 외부 ===필요한 값===> 함수 내부
    - 매개변수(parameter, 인자)를 통해 인수(argument) 전달
- 매개변수
    - 함수 정의 때 선언
    - 함수 몸체 내부에서 변수와 동일 취급
    - 함수 내부 참조⭕️, 함수 외부 참조❌
- 인수
    - ⇒ 표현식
    - 함수 호출 때 지정
    - 개수 & 타입에 제한❌
    - 매개변수보다 많은 경우 → 초과된 인수 무시❗️ → 버려지는 거❌ → 객체의 프로퍼티로 보관

![스크린샷 2024-07-24 오전 1.28.16.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/7538df10-819e-4457-b833-30a2e9e03f7e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.28.16.png)

### **12.5.2 인수 확인**

- 어떤 타입의 인수?? 어떤 타입의 반환 값?? 명확❌ ⇒ 부적절한 호출❗️

![스크린샷 2024-07-24 오전 1.36.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/1023bee1-250e-46d0-9f99-3382c85f69e7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.36.54.png)

![스크린샷 2024-07-24 오전 1.37.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/0d1c2b79-f9ba-4911-ae4d-56a6c97701d8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.37.07.png)

> 💡 문법상 문제❌ → 코드 실행됨‼️
> 
> 
> **1.** 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
> 
> **2.** 자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.
> 

<aside>
💡 정적 타입 선언 가능한 자바스크립트의 상위 확장 도입 ⇒ 부적절한 호출 방지

</aside>

### 12.5.3 매개변수의 최대 개수

- 매개변수가 많아지면??? → 순서 고려 → 객체를 쓰면 순서 신경ㄴㄴ → 아주 편해👍
    - 함수 호출시) 전달해야할 인수의 순서 고려
    - 이해 어렵 & 실수 발생 가능성⬆️
    - 유지보수성⬇️
    - 적을수록 좋아👍
    - 매개변수가 많다? → 함수가 여러가지 일을 함
    - **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다‼️**
- 프로퍼티 키
    - 매개변수의 순서 신경ㄴㄴ
    - 가독성⬆️ & 실수⬇️

### **12.5.4 반환문**

- 함수 : return + 표현식(반환값) ⇒ 함수 외부로 반환(return) 가능‼️
- **함수 호출 = 표현식**
- 반환문
    1. 함수의 실행 중단 → 함수 몸체 빠져나감
    2. return 키워드 뒤에 오는 표현식 평가 → 반환
- 생략⭕️
- 함수 몸체 내부에서만 사용⭕️ → 전역에서 사용❌
- Node.js → 독립적인 파일 스코프 가짐 → 가장 바깥 영역에 반환문 사용 → 에러 발생❌

## 12.6 참조에 의한 전달과 외부 상태의 변경

---

- 원시 값
    - 갑에 의한 전달(pass by value)
- 객체
    - 참조에 의한 전달(pass by reference)
- 매개변수
    - 함수 몸체 내부에서 변수와 동일 취급 → 위 전달 방식 그대로 따름‼️

![스크린샷 2024-07-24 오전 2.05.44.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/421e9c37-317c-4af3-acea-4c285278c094/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.05.44.png)

- 원시 타입 인수
    - 값 자체 복사 → 매개변수에 전달
    - 함수 몸체에서 그 값을 변경 → 원본 훼손❌
    - 즉‼️ 함수 외부 → 내부로 전달한 원시값에 의해 원본 객체 변경❌
- 객체 타입 인수
    - 참조 값 복사 → 매개변수에 전달
    - 함수 몸체에서 참조 값을 통해 객체 변경 → 원본 훼손⭕️
    - 즉‼️ 함수 외부 → 내부로 전달한 참조 값에 의해 원본 객체 변경⭕️

- ChangeVal 함수
    - 원시 타입 인수를 전달받은 매개변수 primitive의 경우) → 원시 값은 직접 변경 불가능한 값(immutable value) → 재할당 → 할당된 원시 값을 새로운 원시 값으로 교체.
    - 객체 타입 인수를 전달받은 매개변수 obj의 경우) → 객체는 직접 변경 가능한 값mutable value → 재할당❌ → 직접 할당된 객체 변경.
- 함수 외부 상태 변경 → 가독성⬇️ → 객체 변경 추적 어려움
    - 해결방법
    ⇒ 객체를 불변 객체(immutable object)로 만들어 사용‼️ → 마치 원시 값처럼 변경 불가능한 값으로 동작 → 객체의 상태 변경❌ → 원본 객체를 완전히 복제(=깊은 복사 deep copy) → 객체 생성 → 재할당 → 교체
    - ⇒ 이를 통해, 외부 상태 변경❌

![스크린샷 2024-07-24 오전 10.38.27.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/9ec5d4c3-bfbd-4b7b-ae52-176c145a7eb4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.38.27.png)

## 12.7 다양한 함수의 형태

---

### 12.7.1 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 함수
- 단 한 번만 호출‼️ 다시 호출 ❌
- 일반적으로 함수 이름❌ 익명 함수 사용
- 반드시 그룹 연산자 ( … )로 감싸야 함
→ 아니면 에러 발생⭕️
- 함수 선언문 뒤의 ( … )는 함수 호출 연산자❌ 그룹 연산자로 해석‼️ → 그룹 연산자에 피연산자가 없으면 에러 발생‼️
- 기명/무명 함수를 그룹 연산자로 감싸면 → 함수 리터럴로 평가 → 함수 객체 생성
    
    ![스크린샷 2024-07-24 오전 10.46.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/685d98b2-57ea-40de-bfb8-b15b189d7163/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.46.14.png)
    
- 값 반환 가능⭕️ 인수 전달 가능⭕️

### 12.7.2 재귀 함수

- 자기 자신을 호출‼️ ⇒ **recursive function**
- 반복되는 처리를 위해 사용됨‼️
- 반복문❌ 구현 가능‼️
    - 예시) 펙토리얼
    
    ![스크린샷 2024-07-24 오전 11.05.25.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/562f899c-d5d3-44fb-a63f-488d8fdd3b73/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.05.25.png)
    
    - 함수 이름 / 식별자 → 자기자신 재귀⭕️
    - 함수 외부에서 함수 호출 시 → 반드시 함수를 가리키는 식별자로 호출‼️
    - 자신을 무한 재귀 → 멈출려면?? → 탈출 조건
    - 스택 탈출조건 없으면?? ⇒ 오버플로(stack overflow)
    
    ![스크린샷 2024-07-24 오전 11.05.46.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/d355046f-58a4-4e5c-bfd3-e39f5403c000/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.05.46.png)
    
    - 재귀함수 = for문 / while문으로 구현
        
        ![스크린샷 2024-07-24 오전 11.09.30.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f5df682a-74e3-4369-9892-f9b16406d42d/579a9a89-b8b1-45d7-bbeb-7d11f9e858d2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-24_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.09.30.png)
        
        - 재귀함수 = 반복되는 처리 → 반복문❌ 구현
        - 무한 반복 / 스택 오버플로 발생 가능

## 12.7.3 중첩 함수

---

- 함수 내부에 정의된 함수 → 중첩 함수(nested function) or 내부 함수(inner function)
    - 중첩함수를 포함 → 외부 함수(outer function)
- 자신을 포함한 외부 함수를 도움 → 헬퍼 함수(helper function)
- if문 / for문 등의 코드 블록에서 함수 정의 → 호이스팅으로 인한 혼란 발생 가능⭕️
- 교체 곤란,,

## 12.7.4 콜백 함수

---

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수(callback function)
    - 함수의 일부분만 다를 때 → 매번 함수를 새롭게 정의 → 추상화로 해결
    - 내부 로직에 강력히 의존❌
    - 외부에서 로직의 일부분을 함수로 전달 받아 수행 → 유연한 구조
- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수 → 고차 함수(Higher-Order Function, HOF)
    - 헬퍼 함수의 역할을 함.
    - 자유롭게 교체⭕️ → why?? →함수 외부에서 고차 함수 내부로 주입하기 때문!!
    - 고차 함수 = 콜백 함수를 자신의 일부분으로 합성
    - 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출.
    - 고차함수에 의해 호출 → 이때 고차 함수는 필요에 따라 콜백 함수에 인수 전달 가능⭕️
    - 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 잘 활용 됨.
- ⭐️⭐️ 자바스크립트에서 배열은 사용 빈도가 매우 높은 자료구조
         → 배열을 다룰 때 배열 고차 함수는 매우 중요‼️

## 12.7.5 순수 함수와 비순수 함수

---

- 순수 함수 pure function
    - 함수형 프로그래밍에서 어떤 외부 상태에 의존❌ 변경❌ → 부수 효과(side effect)❌ 함수
                                                                    → (함수가 만들어진 목적과는 다른 효과 또는 부작용)
    - 동일한 인수가 전달되면 언제나 동일한 값 반환
    - 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존 → 반환값
- 비순수 함수 impure function
    - 함수형 프로그래밍에서 어떤 외부 상태에 의존⭕️ 변경⭕️ → 부수 효과⭕️ 함수
    - 함수의 외부 상태에 따라 반환값 변함.
    - 함수 내부에서 외부 상태를 직접 참조하지 않더라도 → 매개변수를 통해 객체를 전달받으면 → 비순수 함수
    - 사용 최대한 억제 → 함수가 외부 상태를 변경하면 상태 변화 추적 어려움
- 불변성(immutability) 지향‼️

<aside>
💡 **결론‼️**

로직 내에 존재하는 조건문과 반복문 제거 → 복잡성 해결
변수 사용 억제 or 생명주기 최소화 → 상태 변경 피함 → 목표 : 오류 최소화
조건문 or 반복문 → 로직 흐름 이해⬇️ → 가독성⬇️
변수의 값 : 누군가에 의해 언제든지 변경 가능 → 오류 발생의 근본적 원인

함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환‼️

자바스크립트는 멀티 패러다임 언어이므로 객체지향 프로그래밍뿐만 아니라 함수형 프로그래밍을 적극적으로 활용하고 있다‼️
(객체지향프로그래밍: 모든 데이터를 객체로 취급, 함수와 변수를 객체로 그룹핑)
(함수지향프로그래밍: 순수 함수 사용, 빨리 처리, 비절차형 프로그래밍)
(절차지향프로그래밍: 일이 진행되는 순서대로 프로그래밍)

</aside>
# 함수

일련의 과정을 statement로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의

- 함수는 **일급객체**다!
    - 변수 할당 O
    - 파라미터로 전달 O
- 함수는 함수 이름으로 호출하는 것이 아니라 **함수 객체를 가리키는 식별자**로 호출한다!

### 매개변수

함수를 정의할 때 선언하며, 함수 내부에서 변수와 동일하게 취급

1. 함수 호출
2. 함수 몸체 내에서 암묵적으로 매개변수 생성
3. undefined로 초기화
4. 인수가 순서대로 할당됨

- 자바스크립트는 동적타입언어 ⇒ **매개변수 타입 지정 X**
- **매개변수 개수와 인수의 개수 체크 안함** ⇒ 에러도 발생 안됨
    - 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 **undefined**
    - 초과된 인수는 arguments 객체의 프로퍼티로 암묵적으로 보관됨

```jsx
function func(x,y) { 
	console.log(arguments)
	return x * y 
}

console.log(func(1)) //1 * undefined -> NaN
console.log(func(1,2,3,4) //1*2 -> 2 arguments : [1,2,3,4]
```

따라서 적절한 인수가 전달되었는지 확인해야 한다~

- 자료형 : typeof로 확인 가능
- 인수 개수 : arguments로 확인 or 매개변수에 기본값 할당
    - function func(x=1, y=2) {return x*y} 기본값 할당

### 함수 사용 이유

1. 코드의 중복 억제
2. 유지보수의 편의성
3. 코드의 신뢰성
4. 가독성 향상 

### 함수 정의

**1️⃣ 함수 선언문**

- 함수 리터럴과 형태는 동일하나, **함수 이름을 생략할 수 없다**는게 차이점
- ‘선언’문은 **변수에 할당 불가**
- 형태가 동일하기 때문에 js엔진이 코드의 문맥에 따라 선언문 또는 리터럴로 알아서 해석을 함

```jsx
//함수 선언문
function mul(x,y) {
	console.log(x * y)
}

mul(2,5) //함수 이름을 암묵적으로 식별자로 생성

var add = function add(x,y) {
	return x + y
	}//함수 리터럴로 해석되어 변수에 할당됨
	
console.log(add(2,5)) //함수 리터럴에서는 변수가 곧 식별자
```

- 그룹 연산자( ) 내에 있는 함수
    - 그룹 연산자의 피연산자는 값으로 평가되는 표현식이여야 함
        
        ⇒ js엔진이 함수 리터럴 표현식으로 해석
        

```jsx
(function func() {console.log('함수')})

func() //함수 호출 불가: func is not defined
//함수 리터럴에서 식별자는 변수인데 할당되지 않았으니까 not defined 상태
```

- 함수 생성시점
    1. 런타임 이전에 함수 객체가 먼저 생성된다.
    2. js엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성한다. 
    3. 생성된 함수 객체를 할당한다. 
    
    ⇒ 함수 선언문이 코드 선두로 끌어 올려진 것처럼 동작 ( = 함수 호이스팅)
    
    ⇒ 함수 선언문 이전에 함수 호출 시 정상 호출
    
    (cf. 변수 호이스팅의 경우 선언만 먼저 동작하기 때문에 undefined로 초기화된다!)
    

**2️⃣ 함수 리터럴**

구성요소

- 함수이름 : 함수 몸체 내에서만 참조할 수 있는 식별자로, 이름 생략 가능함
- 매개변수
    - 0개 이상의 매개변수
    - 함수 몸체 내에서 변수와 동일하게 취급
- 함수 몸체 : 실행문 정의된 코드블록

```jsx
var f = function sum(x,y) {
	return x + y
}//함수는 객체다~! (변수할당)

console.log(sum(1,3)) //ERROR: 함수 이름은 함수 내부에서만 식별 가능
console.log(f(1,3)) //4
```

- 함수 생성시점
    - 함수 리터럴을 통한 생성 시점은 변수 선언 및 할당과 동일
    - 할당문이 실행되는 시점에 평가되어 함수 객체가 됨
    - 함수 호이스팅이 아니라 변수 호이스팅이 발생하는 것!
    - 함수 표현식 이전에 함수를 참조 or 호출할 경우 undefined를 호출하는 것이기 때문에 에러가 발생
    - 반드시 함수 표현식 이후 호출!!
    - 함수 선언문보다 함수 표현식이 더 권장됨

**3️⃣ Function 생성자 함수**

- Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달
- new 연산자와 함께(생략 가능) 호출 시 함수 객체를 생성해서 반환
- 딱히 권장되는 방법은 아님
    - 클로저를 생성하지 않는 등, 함수 선언문이나 함수 리터럴로 생성한 함수와 다르게 동작

```jsx
var sum = new Function(’x’, ‘y’, ‘return x + y’)
```

**4️⃣ ES6 - 화살표 함수**

- 생성자 함수로 사용 불가
- this 바인딩 방식이 다름
    - 자신이 호출되면서 생성된 실행 콘텍스트에서 thisBinding 정보를 생성하지 않는다
    - 화살표 함수가 선언되어 있는 실행 콘텍스트가 참조하는 thisBinding 정보를 참조
- arguments 객체를 생성하지 않음
- prototype 프로퍼티가 없음
    - 자신의 인스턴스 객체가 만들어질 수 없다

```jsx
const 변수 = (파라미터 목록) => 함수 몸체 리턴문
```

cf. prototype

상속되는 속성과 메소드들은 객체 생성자의 prototype이라는 속성에 정의됨

상속 관계로 만드는데 쓰이나봄 

```jsx
let animal = {eats: true}
function Rabbit() { }

Rabbit.prototype = animal

let rabbit = new Rabbit(); //  rabbit.__proto__ == animal

alert(rabbit.eats); // true
```

### 함수 호출

- 값에 의한 호출
    - 원시값은 값 자체가 복사되어 전달된다.
    - 원본이 훼손되지 않는다.
- 참조에 의한 호출
    - 객체는 참조값이 복사되어 전달된다.
    - 원본을 직접 변경한다.

```jsx
function change(primitive, obj) {
	primitive += 100
	obj.key = 'hihi'
}

var num = 1
var o = {key:'ㅡ.ㅡ'}

change(num, o)

console.log(num)  //1
console.log(o)  //{key:'hihi'}
```

함수가 외부상태를 변경하는 경우 상태 변화 추적이 어렵고 코드의 복잡성을 증가시킴

⇒ 해결방법 : 객체를 불변객체로 만들어 사용하자!

원본 객체를 완전히 복제(깊은 복사)한 새로운 객체를 생성하고 재할당을 통해 교체해서 함수 내부에서 사용하도록

기존 객체는 보존됨

### 함수 종류

1️⃣ 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출됨
- 단 한번만 호출되며, 재호출 불가능
- 반드시 그룹 연산자로 감싸져야 함
    - 안감싸면 function부분은 함수 선언문으로 해석하고, ( ) 부분은 그룹연산자로 해석
    - ( )에 피연산자가 암것도 없어서 SyntaxError 발생
- 값 반환, 인수 전달 가능

```jsx
function (a,b) {실행문}()  //SyntaxError!

(function (a,b) {실행문}()); //익명함수 사용

(function func(a,b){실행문}()); //함수 리터럴로 해석되는 함수객체
func(a,b) //not defined (재호출 불가)

var res = (function (a,b) {
	return a/b
	}(10,5));  //res = 2
```

2️⃣ 재귀함수

 ※ 탈출 조건 필수 ※

- 재귀호출 시 변수명 or 함수 이름으로 자기자신 호출할 수 있음

3️⃣ 중첩함수

내부함수 : 함수 내부에 정의된 함수

외부함수 : 중첩함수를 포함하는 함수

- 내부함수는 외부함수의 안에서만 호출할 수 있다
- 내부함수에서는 외부함수의 변수를 쓸 수 있음

4️⃣ 콜백함수

콜백함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

고차함수 : 매개변수를 통해 콜백함수를 전달받는 함수

- 함수의 변하지 않는 공통 로직을 미리 정의해두고, 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달될 수 있게 해줌
- 고차함수가 호출되어야 콜백함수가 실행됨
- 고차함수에 콜백함수를 전달할 때, 호출하는게 아니라 함수 자체를 전달해야 함

```jsx
function gocha(N, callback) {
	for(let i=0; i<N; i++){//N번씩 함수를 실행하는 공통로직
		callback(i)
	} 
	
var printAll = function (i) {
	console.log(i)
}

//반복문 도는 값을 출력하는 함수를 인자로 전달
gocha(5, printAll) //printAll() X

//짝수만 출력하는 함수를 인자로 전달
gocha(5, function (i) {
	if(i%2==0)
		console.log(i)
}) //function() {}() 형태X
```

5️⃣ 순수함수 / 비순수함수

- 순수함수 : 외부 상태에 의존하지 않고 외부 상태를 변경하지 않는 함수
    - 동일한 인수가 전달되면 언제나 동일한 값을 반환
    - 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존
- 비순수함수 : 외부 상태에 의존하거나 외부 상태를 변경하는 함수
    - 함수 내부에서 외부 상태를 직접 참조하는 경우
    - 매개변수를 통해 객체를 전달받는 경우

```jsx
var count = 0

//순수함수
var v = function (i) {
	return ++i
	}(count); //v = 1, count = 0
	
//비순수함수
var v = function () {
	return ++count
	}(); //v = 1, count = 1
```
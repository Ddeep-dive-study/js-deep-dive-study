자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징이 있어서 주의 필요!

var 변수의 스코프와 let, const 변수의 스코프 다르게 동작

스코프는 변수/함수와 깊은 관련이 있음

# 스코프(Scope)란?

→ 식별자가 유효한 범위

→ (자바스크립트 엔진이) 식별자를 검색할 때 사용하는 규칙

모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 선언된 위치에 따라 다른 코드가 자신을 참조할 수 있는 유효범위가 결정됨

### 식별자 결정(identifier resolution)

자바스크립트 엔진이 동명이변(이름 같은 두 변수) 중 어떤 변수를 참조할 것인지 결정하는 것

<aside>
💡 어떻게? 스코프(규칙)를 통해!

</aside>

자바스크립트 엔진은 코드 실행 시 `코드의 문맥(context)를 고려`

`코드가 어디서 실행되며, 주변에 어떤 코드가 있는지`에 따라 동일한 코드도 다른 결과

```jsx
var x = "global";

function foo() {
  var x = "local";
  console.log(x); //1️⃣
}

foo();

console.log(x); //2️⃣
```

- 출력
  ```jsx
  local;
  global;
  ```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0bca5692-602f-4dd1-8b56-409be75fe4d6/59bd1665-87c5-426b-a693-3ea01add02fb/Untitled.png)

- 스코프 라는 개념이 없다면,
  위에 코드에서 ’x’ 변수가 전역, foo 함수 모두 존재 → 충돌 할 것
- 식별자는 어떤 값을 구별할 수 있어야 하므로 유일(unique)해야 함
- 따라서 식별자인 변수 이름은 중복될 수 없음 → 하나의 값은 유일한 식별자에 연결되어야 함

```jsx
흰둥이 두마리 -> 얘기할 때 소속을 말하지 않으면 누구를 말하는지 구분 불가
'짱구네' 흰둥이 , '철수네' 흰둥이 처럼 소속 있으면 동일한 이름도 구분 가능!
```

- var 키워드로 선언한 변수의 중복 선언
  var 변수 → 같은 스코프 내에서 중복 선언 허용
                의도치 않게 변수값이 재할당되어 변경되는 부작용 발생!
  let, const 변수 → 같은 스코프 내에서 중복 선언 허용 X

# 스코프 종류

변수는 선언된 위치(전역/지역)에 의해 스코프 결정됨

| 구분 | 설명                  | 스코프      | 변수      | 변수 유효범위                                    |
| ---- | --------------------- | ----------- | --------- | ------------------------------------------------ |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 | 어디서든지 참조가능                              |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 | 자신의 지역 스코프와 하위 지역 스코프에서 유효함 |

# 스코프 체인

### 함수의 중첩

함수 몸체 내부에서 다른 함수가 정의된 것

중첩 함수 → 함수 내부에 정의된 함수

외부 함수 → 중첩 함수를 포함하는 함수

함수는 중첩 가능하므로 함수의 지역 스코프도 중첩 가능

→ 스코프가 함수의 중첩에 의해 계층적 구조를 가짐!

외부함수의 지역 스코프 == 중첩 함수의 상위 스코프

### 스코프 체인

스코프가 계층적으로 연결된 것

모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프

자바스크립트 엔진은 변수 참조 시 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색(`식별자 결정 identifier resolution`)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0bca5692-602f-4dd1-8b56-409be75fe4d6/c7222bee-152b-487c-a1d5-a26ad0462996/Untitled.png)

<aside>
💡 **렉시컬 환경 Lexical Environment**

자바스크립트 엔진은 코드(전역 코드와 함수 코드)를 실행하기 전 렉시컬 환경(위 그림과 유사한 자료 구조)을 실제로 생성함

변수 선언 → 변수 식별자가 렉시컬 환경에 키(key)로 등록됨

변수 할당 → 변수 식별자(key)에 해당하는 값을 변경함

변수 검색 → 렉시컬 환경 상에서 이뤄짐

스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것

전역 렉시컬 환경 → 코드가 로드되면 곧바로 생성됨

함수의 렉시컬 환경 → 함수 호출되면 곧바로 생성됨

</aside>

### 변수 검색

상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 가능

하위 스코프에서 유효한 변수를 상위 스코프에서 참조하는 건 불가

⇒ 절대 내려가면서 검색하지 X

### 함수 검색

함수 선언문으로 함수 정의 → 런타임 이전에 함수 객체가 먼저 생성(함수 호이스팅)

→ 자바스크립트 엔진은 함수명과 동일한 이름의 식별자를 암묵적으로 선언 → 식별자에 함수 객체 할당

foo함수 호출하면 자바 스크립트 엔진은 함수를 가리키는 식별자 foo를 검색

함수도 식별자에 할당되므로 스코프를 가짐

⇒ 따라서 스코프를 “**식별자**를 검색하는 규칙”이라고 표현하는 것

# 함수 레벨 스코프

### 블록 레벨 스코프

함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만듦

C나 JAVA 등 대부분의 PL

### 함수 레벨 스코프

JS에서 var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정

```jsx
var x = 1;

if (true) {
  // if문 블록 내부에서 선언한 변수 x는 지역 스코프 적용 X
  // 따라서, 아래의 변수 x는 전역 변수
  // 이미 선언된 전역 변수 x 존재 -> 중복 선언
  // 의도치 않게 변수 값이 재할당되는 부작용 발생
  var x = 10;
}

console.log(x); // 10
```

# ⭐️ 렉시컬 스코프

- **클로저**와 깊은 관계
  클로저 → 내부 함수에서 외부 함수의 범위에 대한 접근을 제공

### 렉시컬(정적) 스코프 lexical(static) scope

함수를 어디서 정의했는지에 따라 상위 스코프 결정

자바스크립트는 렉시컬 스코프를 따름

함수가 호출된 위치는 상위 스코프 결정에 영향 주지 X

함수 정의가 실행될 때 상위 스코프 결정되고, 이를 기억하여 함수 호출 시 상위 스코프를 참조

### 동적 스코프 dynamic scope

함수를 어디서 호출했는지에 따라 상위 스코프 결정

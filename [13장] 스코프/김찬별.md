# 스코프

모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는데, 이를 스코프라고 함

- 전역 스코프에서 선언된 변수 = 전역변수
- 지역 스코프에서 선언된 변수 = 지역변수

### 식별자 결정

- 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 하는지 결정
    
    ⇒ 스코프는 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이다!
    

```jsx
    var x = 'global'
    function foo() {
        var x = 'local'
        console.log(x)  //local
    }
    foo()
    console.log(x) //global
```

- global이 담겨있는 변수x는 가장 바깥 영역에 선언되어 어디서든지 참조할 수 있다
- local이 담겨있는 변수x는 foo함수 내부에서만 참조 가능하고 외부에서는 참조할 수 없다

### 변수 이름 충돌 방지

- 스코프를 통해 식별자 변수 이름의 충돌을 방지
- 다른 스코프끼리는 중복되는 이름의 변수 사용 가능
    - var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언 허용 :  중복 선언 시 var 키워드가 없는 것처럼 동작해서 재할당함
    - let, const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언 불가

## 종류

**1️⃣ 전역 스코프와 전역 변수**

- 전역 : 코드의 가장 바깥 영역
- 전역 변수는 어디서든지 참조할 수 있음

**2️⃣ 지역 스코프와 지역 변수**

- 지역 : 함수 몸체 내부
- 지역 변수는 자신의 지역 스코프와 하위의 지역 스코프에서 유효함
- 외부에서 참조할 수 없음

<aside>
💡 함수 레벨 스코프
- 다른 언어들은 함수 몸체만이 아니라 조건문, 반복문 등의 블록들도 지역 스코프를 만듬 (=블록 레벨 스코프)

- 근데 var키워드로 선언된 변수는 오직 함수 코드 블록만 지역 스코프로 인정함

```jsx
var x = 1
if(true) {
	var x = 10
}

console.log(x) //10

* 함수 코드 블록이 아닌 if문, for문 등의 코드 블록에서 선언된 경우 전역 변수로 인식함
  => x에 10을 재할당
```

</aside>

<aside>
💡 함수 내부에서 선언된 변수 A와 이름이 같은 전역 변수 A가 있을 때, 함수 내부에서 A를 참조하면 전역 변수가 아닌 함수 내부에서 선언된 A를 참조함

⏩⏩⏩ 자바스크립트 엔진이 스코프 체인을 통해 참조할 변수를 검색했기 때문이다!

</aside>

## 스코프 체인

함수의 중첩에 의해서 스코프가 계층적인 구조로 연결된 것

스코프 체인은 물리적인 실체로 존재함 

→ 코드 실행 전 렉시컬 환경을 생성

→ 변수 선언이 실행 시 식별자가 key로 등록됨 

→ 변수 할당 시 value 변경

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/90f0cea1-2c0a-45ef-8fdd-d99b6da3fa09/6cd083ee-660b-4e45-b88c-a3e52bcff80c/Untitled.png)

- 최상위 스코프 : 전역 스코프
- 변수 참조 시
    - 자바스크립트 엔진  →  스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작
    - 상위 스코프 방향으로 이동하며 변수 검색
    
- 상위 스코프에서 선언한 변수를 하위 스코프에서 참조할 수 있음
    - 상속 관계랑 비슷하네 상위가 부모 - 하위가 자식
- 하위 스코프에서 유효한 변수를 상위 스코프에서는 참조할 수 없다!

- 함수 검색

```jsx
function foo() {
        console.log('global func')
    }

    function bar() {
        function foo() {
            console.log('local func');
        }
        foo()
    }
    bar()
    
* 함수 선언문으로 정의하면 호이스팅 때문에 런타임 이전에 함수 객체가 먼저 생성됨! 
	=> 'global func' 먼저 출력

* bar()함수가 호출된 후 local foo()실행되어서 'local func' 출력
```

### 함수의 상위 스코프 결정

자바 스크립트는 **함수를 어디서 정의했는지**에 따라 함수의 상위 스코프를 결정한다!

**== 랙시컬 스코프**

- 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정됨
- 함수가 호출되는 위치는 상위 스코프 결정에 영향XXXX

```jsx
var x = 1

function f1() {
	var x = 10
	v2()
}

function f2() {
	console.log(x)
}

f1()
f2()

실행결과는?
- f1의 함수 선언과 f2의 함수 선언 모두 전역에서 정의됨
- 호출된 곳이 어디인지 관계 없이 자신이 정의된 스코프인 전역 스코프가 상위 스코프가 된다
- 따라서 1이 두 번 출력됨
```